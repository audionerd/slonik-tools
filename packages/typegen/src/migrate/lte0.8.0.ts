import * as fs from 'fs'
import type * as ts from 'typescript'
import * as lodash from 'lodash'
import {Logger} from '../types'
import * as assert from 'assert'
import {prettifyOne} from '../write/prettify'

interface Edit {
  start: number
  end: number
  replacement: string
}

type FileChange = {type: 'delete'; file: string} | {type: 'write'; file: string; content: string}

export const v080FileMarker = `
/* eslint-disable */
// tslint:disable
// this file is generated by a tool; don't change it manually.
`.trim()

export const isPreV080File = (content: string) => {
  // unfortunately there's no clear-cut marker indicating "this is an @slonik/typegen generated file", so use this heuristic
  const allRequired = [
    `/* eslint-disable */`,
    `// tslint:disable`,
    `// this file is generated by a tool; don't change it manually.`,
  ]

  const someRequired = [
    // *just* in case some other file has the above comments, use these to be a bit more sure it's old @slonik/typegen code
    'export const _pg_types',
    'export interface KnownTypes',
    'meta_v0',
  ]

  return allRequired.every(line => content.includes(line)) && someRequired.some(line => content.includes(line))
}

export const migrate080 = ({files, logger}: {files: string[]; logger: Logger}) => {
  const changes: FileChange[] = files.flatMap(file => getChanges(file))

  changes.forEach(change => {
    if (change.type === 'delete') {
      logger.info(`Deleting file ${change.file}`)
      fs.unlinkSync(change.file)
    }
    if (change.type === 'write') {
      logger.info(`Updating file ${change.file}`)
      fs.writeFileSync(change.file, prettifyOne({filepath: change.file, content: change.content}))

      const warningPhrase = 'poolConfig'
      const warnings = change.content
        .split('\n')
        .map((line, i) => ({
          message: `"${warningPhrase}" should be removed manually`,
          line: i + 1,
          column: line.indexOf(warningPhrase) + 1,
        }))
        .filter(warning => warning.column > 0)

      warnings.forEach(warn => {
        logger.warn(`WARNING: ${warn.message} - ${change.file}:${warn.line}:${warn.column}`)
      })
    }
  })
}

const getChanges = (file: string): [FileChange] | [] => {
  const ts: typeof import('typescript') = require('typescript')
  const origSource = fs.readFileSync(file).toString()

  if (isPreV080File(origSource)) {
    return [{type: 'delete', file}]
  }

  const sourceFile = ts.createSourceFile(file, origSource, ts.ScriptTarget.ES2015, /*setParentNodes */ true)

  const edits: Edit[] = []

  const importSqlFromSlonik = [`import { sql } from 'slonik'`]

  const getImportSqlFromSlonik = () => importSqlFromSlonik.pop() || ''

  visitNodes(sourceFile)

  const newContent = lodash
    .sortBy(edits, e => e.end)
    .reduceRight((source, edit) => source.slice(0, edit.start) + edit.replacement + source.slice(edit.end), origSource)

  return edits.length === 0 ? [] : [{type: 'write', file, content: newContent}]

  function visitNodes(node: ts.Node) {
    if (ts.isImportDeclaration(node)) {
      if (node.importClause?.namedBindings && ts.isNamedImports(node.importClause.namedBindings)) {
        const namedImports = node.importClause.namedBindings.elements

        const sqlImport = namedImports.find(e => e.name.escapedText === 'sql')
        const knownTypesImport = namedImports.find(e => e.name.escapedText === 'knownTypes')
        const setupTypeGenImport = namedImports.find(e => e.name.escapedText === 'setupTypeGen')

        const soloSqlImport = sqlImport && namedImports.length === 1

        if (soloSqlImport || knownTypesImport || setupTypeGenImport) {
          edits.push({
            start: node.getStart(sourceFile),
            end: node.getEnd(),
            replacement: getImportSqlFromSlonik(),
          })
        } else if (sqlImport) {
          let start = sqlImport.getStart(sourceFile)
          let end = sqlImport.getEnd()

          while (origSource[start - 1] === ' ') {
            start -= 1
          }
          if (origSource[start - 1] === ',') {
            start -= 1
          } else {
            while (['', ','].includes(origSource[end])) {
              end += 1
            }
          }

          edits.push({
            start,
            end,
            replacement: '',
          })
          edits.push({
            start: node.getStart(sourceFile),
            end: node.getStart(sourceFile),
            replacement: `${getImportSqlFromSlonik()}\n`,
          })
        }
      }
    }

    if (ts.isTaggedTemplateExpression(node)) {
      if (ts.isPropertyAccessExpression(node.tag)) {
        if (node.tag.expression.getText() === 'sql') {
          edits.push({
            start: node.tag.getStart(sourceFile),
            end: node.tag.getEnd(),
            replacement: 'sql',
          })
        }
      }
    }

    if (ts.isCallExpression(node)) {
      if (node.expression.getText().endsWith('setupTypeGen')) {
        let parent: ts.Node | undefined = node
        while (parent && !ts.isExpressionStatement(parent) && !ts.isVariableStatement(parent)) {
          parent = parent.parent
        }

        assert.ok(
          parent,
          `setupTypeGen expected to be part of a variable or expresion statement. Try again after manually deleting setupTypeGen in file ${file}`,
        )

        edits.push({
          start: parent.getStart(sourceFile),
          end: node.getEnd(),
          replacement:
            '/* setupTypeGen call removed. There may be remaining references to poolConfig which should be deleted manually */',
        })
      }
    }

    ts.forEachChild(node, visitNodes)
  }
}
